// HTML Fact-Check Report Generator
const allResults = $input.all();
const reportDate = new Date().toLocaleDateString('en-US'); // MM/DD/YYYY format

// Extract basic info and clean title
const rawTitle = allResults[0]?.json?.Title?.replace(/^=/, '') || allResults[0]?.json?.doc_id || 'Unknown Document';
const docTitle = rawTitle.replace(/\n/g, '').trim(); // Clean newline characters
const totalClaims = allResults.length;

// Count final verdicts
const verdictCounts = {};
allResults.forEach(item => {
  const verdict = item.json.final_verdict || 'Unknown';
  verdictCounts[verdict] = (verdictCounts[verdict] || 0) + 1;
});

// Sort results by verdict priority: True, Partially True, False, Unverifiable
const verdictOrder = {'True': 1, 'Partially True': 2, 'False': 3, 'Unverifiable': 4};
const sortedResults = [...allResults].sort((a, b) => {
  const aVerdict = a.json.final_verdict || 'Unverifiable';
  const bVerdict = b.json.final_verdict || 'Unverifiable';
  return (verdictOrder[aVerdict] || 999) - (verdictOrder[bVerdict] || 999);
});

// Generate clean HTML
const htmlReport = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Fact Check Analysis & Source Verification</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f1f5f9; padding: 20px; }
        .container { max-width: 940px; margin: auto; background: #fff; border-radius: 14px; box-shadow: 0 6px 18px rgba(0,0,0,.08); }
        .header { background: #2c3e50; color: #fff; text-align: center; padding: 20px; border-radius: 14px 14px 0 0; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; font-weight: 300; }
        .header .meta { opacity: 0.9; font-size: 1.1em; }
        
        .summary { padding: 30px; background: #f8f9fa; border-bottom: 1px solid #eee; }
        .summary h2 { color: #2c3e50; margin-bottom: 20px; font-size: 1.8em; }
        
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0; }
        .stat { background: white; padding: 20px; border-radius: 10px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.08); border-left: 4px solid; }
        .stat.true { border-left-color: #27ae60; }
        .stat.false { border-left-color: #e74c3c; }
        .stat.partially-true { border-left-color: #f39c12; }
        .stat.unverifiable { border-left-color: #95a5a6; }
        .stat-number { font-size: 2.5em; font-weight: bold; margin-bottom: 5px; }
        .stat-label { color: #666; font-size: 0.9em; }
        
        .claims-section { padding: 30px; }
        .claims-section h2 { color: #2c3e50; margin-bottom: 30px; font-size: 1.8em; }
        
        .claim { border: 1px solid #eee; border-radius: 10px; margin: 20px 0; overflow: hidden; transition: transform 0.2s, box-shadow 0.2s; }
        .claim:hover { transform: translateY(-2px); box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
        .claim-header { background: #f8f9fa; padding: 15px 20px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; }
        .claim-number { font-weight: bold; color: #2c3e50; }
        .verdict { padding: 8px 16px; border-radius: 20px; font-weight: bold; font-size: 0.9em; }
        .verdict-true { background: #d4edda; color: #155724; }
        .verdict-false { background: #f8d7da; color: #721c24; }
        .verdict-partially-true { background: #fff3cd; color: #856404; }
        .verdict-unverifiable { background: #e2e3e5; color: #383d41; }
        
        .claim-text, .explanation { padding: 15px 20px; }
        .claim-text { border-bottom: 1px solid #f0f0f0; }
        .explanation { background: #fafafa; }
        
        .sources-section { padding: 30px; background: #f8f9fa; border-top: 1px solid #eee; }
        .sources-section h2 { color: #2c3e50; margin-bottom: 20px; font-size: 1.8em; }
        .source-category { margin: 20px 0; }
        .source-category h3 { color: #495057; margin-bottom: 10px; }
        .source-category p { margin: 10px 0; color: #666; }
        .source-category ul { margin: 10px 0; padding-left: 20px; }
        .source-category li { margin: 8px 0; }
        
        .methodology { background: #2c3e50; color: white; padding: 20px; text-align: center; border-radius: 0 0 14px 14px; }
        .methodology h3 { margin-bottom: 15px; font-size: 1.5em; }
        .methodology p { opacity: 0.9; max-width: 600px; margin: 0 auto; }
        
        @media (max-width: 768px) {
            .claim-header { flex-direction: column; align-items: stretch; text-align: center; }
            .container { margin: 10px; border-radius: 10px; }
            body { padding: 10px; }
            .header h1 { font-size: 2em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Fact Check Analysis & Source Verification</h1>
            <div class="meta">
                <strong>${docTitle}</strong><br>
                Generated: ${reportDate} • ${totalClaims} Claims Analyzed
            </div>
        </div>
        
        <div class="summary">
            <h2>Summary</h2>
            <div class="stats">
                <div class="stat true">
                    <div class="stat-number" style="color: #27ae60;">${verdictCounts['True'] || 0}</div>
                    <div class="stat-label">True (${((verdictCounts['True'] || 0) / totalClaims * 100).toFixed(1)}%)</div>
                </div>
                <div class="stat partially-true">
                    <div class="stat-number" style="color: #f39c12;">${(verdictCounts['Partially True'] || 0) + (verdictCounts['Partial'] || 0)}</div>
                    <div class="stat-label">Part True (${(((verdictCounts['Partially True'] || 0) + (verdictCounts['Partial'] || 0)) / totalClaims * 100).toFixed(1)}%)</div>
                </div>
                <div class="stat false">
                    <div class="stat-number" style="color: #e74c3c;">${verdictCounts['False'] || 0}</div>
                    <div class="stat-label">False (${((verdictCounts['False'] || 0) / totalClaims * 100).toFixed(1)}%)</div>
                </div>
                <div class="stat unverifiable">
                    <div class="stat-number" style="color: #95a5a6;">${verdictCounts['Unverifiable'] || 0}</div>
                    <div class="stat-label">Unverified (${((verdictCounts['Unverifiable'] || 0) / totalClaims * 100).toFixed(1)}%)</div>
                </div>
            </div>
        </div>
        
        <div class="claims-section">
            <h2>Detailed Analysis</h2>
            ${sortedResults.map((item, index) => {
                const verdict = item.json.final_verdict || 'Unknown';
                // Fix CSS class generation - ensure it matches our CSS classes
                let verdictClass;
                if (verdict === 'True') verdictClass = 'true';
                else if (verdict === 'False') verdictClass = 'false';
                else if (verdict === 'Partially True') verdictClass = 'partially-true';
                else if (verdict === 'Unverifiable') verdictClass = 'unverifiable';
                else verdictClass = 'unverifiable';
                
                // Add warning icon for Partially True
                const displayVerdict = verdict === 'Partially True' ? '⚠️ Part True' : verdict;
                const showAnalysis = verdict !== 'True';
                
                return `<div class="claim">
                    <div class="claim-header">
                        <span class="claim-number">Claim ${index + 1}</span>
                        <span class="verdict verdict-${verdictClass}">${displayVerdict}</span>
                    </div>
                    <div class="claim-text">
                        <strong>Claim:</strong> ${item.json.claim_text || 'Unknown claim'}
                    </div>
                    ${showAnalysis ? `<div class="explanation">
                        <strong>Analysis:</strong> ${item.json.explanation || item.json.perplexity_explanation || item.json.serpapi_explanation || item.json.tiebreaker_explanation || 'Analysis not available'}
                    </div>` : ''}
                </div>`;
            }).join('')}
        </div>

        <div class="sources-section">
            <h2>Source References</h2>
            ${(() => {
                // Collect all sources from all fact-checking services
                const allFactCheckSources = new Set();
                const unsupportedPdfSources = new Set();
                
                // Helper function to clean Google redirect URLs
                function cleanGoogleRedirectUrl(url) {
                    if (url.includes('google.com/url?q=')) {
                        const match = url.match(/[?&]q=([^&]+)/);
                        if (match) {
                            return decodeURIComponent(match[1]);
                        }
                    }
                    return url;
                }
                
                allResults.forEach((item, i) => {
                    // Get sources from final_sources
                    const finalSources = item.json.final_sources || [];
                    finalSources.forEach(url => {
                        if (typeof url === 'string' && url.startsWith('http')) {
                            let cleanUrl = cleanGoogleRedirectUrl(url);
                            allFactCheckSources.add(cleanUrl);
                        }
                    });
                    
                    // Check for unsupported PDF sources in unsupported_urls field
                    const unsupportedUrls = item.json.unsupported_urls || [];
                    unsupportedUrls.forEach(url => {
                        if (typeof url === 'string' && url.startsWith('http')) {
                            let cleanUrl = cleanGoogleRedirectUrl(url);
                            if (cleanUrl.toLowerCase().includes('.pdf')) {
                                unsupportedPdfSources.add(cleanUrl);
                            }
                            allFactCheckSources.add(cleanUrl);
                        }
                    });
                    
                    // Look for SerpAPI sources in various possible fields
                    const possibleSourceFields = [
                        'serpapi_sources', 'perplexity_sources', 'tiebreaker_sources',
                        'sources_used', 'external_sources', 'research_sources',
                        'fact_check_sources', 'supporting_sources', 'checked_urls',
                        'supporting_urls', 'sources_considered'
                    ];
                    
                    possibleSourceFields.forEach(field => {
                        if (item.json[field]) {
                            if (Array.isArray(item.json[field])) {
                                item.json[field].forEach(source => {
                                    if (typeof source === 'string' && source.startsWith('http')) {
                                        let cleanUrl = cleanGoogleRedirectUrl(source);
                                        allFactCheckSources.add(cleanUrl);
                                    }
                                });
                            } else if (typeof item.json[field] === 'string' && item.json[field].startsWith('http')) {
                                let cleanUrl = cleanGoogleRedirectUrl(item.json[field]);
                                allFactCheckSources.add(cleanUrl);
                            }
                        }
                    });
                });
                
                let sourcesHtml = '';
                
                // Show all fact-checking sources
                if (allFactCheckSources.size > 0) {
                    sourcesHtml += `<div class="source-category">
                        <p>Sources used during the fact-checking process:</p>
                        <ul>
                            ${Array.from(allFactCheckSources).sort().map(url => 
                                `<li><a href="${url}" target="_blank">${url}</a></li>`
                            ).join('')}
                        </ul>
                    </div>`;
                }
                
                // Highlight unsupported PDF sources
                if (unsupportedPdfSources.size > 0) {
                    sourcesHtml += `<div class="source-category">
                        <h3>⚠️ Unsupported PDF Sources</h3>
                        <p style="color: #e74c3c; font-weight: bold;">These PDF sources from the original document could not support the claims. Please review manually:</p>
                        <ul>
                            ${Array.from(unsupportedPdfSources).sort().map(url => 
                                `<li style="background: #fff3cd; padding: 8px; margin: 5px 0; border-left: 4px solid #f39c12;">
                                    <a href="${url}" target="_blank" style="color: #856404; font-weight: bold;">${url}</a>
                                    <br><em style="color: #856404;">Manual verification recommended</em>
                                </li>`
                            ).join('')}
                        </ul>
                    </div>`;
                }
                
                // If no sources found at all
                if (allFactCheckSources.size === 0 && unsupportedPdfSources.size === 0) {
                    sourcesHtml += `<div class="source-category">
                        <p>Analysis was conducted using established methodologies and available reference materials.</p>
                    </div>`;
                }
                
                return sourcesHtml;
            })()}
        </div>

        <div class="methodology">
            <h3>Methodology</h3>
            <p>This analysis was conducted using AI-powered fact-checkers including Perplexity AI and SerpAPI, with Claude AI providing tie-breaker analysis for conflicting results.</p>
        </div>
    </div>
</body>
</html>`;

return [{ json: { report_content: htmlReport } }];
